<link rel="stylesheet" href="/gui/css/chat.css">

<div id="chat" class="section-profile">
    <div class="chat-popup form-container" id="myForm">
        <div id="chat-header" onclick="toggleChat()">
            <p id="chat-header-text">Conversations</p><img id="chat-header-button" src="/gui/img/min.png">
        </div>
        <div id="chat-body">
            <ul id="chatter"></ul>
        </div>
        <div id="chat-footer">
            <input id="mymsg" type="text" placeholder="Type message.." name="msg"/>
        </div>
    </div>
</div>

<li id="chat-line" style="display: none">
    <p id="chat-user"></p><p id="chat-line-text"></p>
    <p id="timestamp"></p>
</li>

<script>
    let config = {{config|safe}};
    let confPort = config['app.contact.websocket'];
    confPort = confPort.slice(confPort.lastIndexOf(':')+1);

    let machine = {};
    $.ajax({
        url:'/api/rest',
        type:"POST",
        data:JSON.stringify({'index':'machine_info'}),
        success:function(resp){machine=resp;},
        async: false
    });
    let username = (config.chat_username)?config.chat_username:machine.user;
    let team = {};
    console.log(username + ' ' + machine.ip);

    testConnectivity();
    toggleChat();

    function connectToUser(user, ip, port) {
        let websocket = new WebSocket('ws://'+ip+':'+port+'/chat');
        websocket.onopen = function(evt) {
            console.log('connected on: '+ ip + ':' + port);
            websocket.addEventListener('message', event => {
                handleIncomingMessage(event.data, user);
            });
            team[user] = websocket;
        };
        websocket.onerror = function(evt) {
            console.log('error on: '+ ip);
            writeMessage(user +' is offline', false, Date.now());
        };
        websocket.onclose = function(evt) {
            console.log('connection to ' + user + '[' + ip + '] closed')
        };
    }

    function testConnectivity(){
        Object.keys(config.teammates).forEach(function(user) {
            let ip = config.teammates[user];
            connectToUser(user, ip, confPort)
        });
        beaconOthers();
    }

    function beaconOthers() {
        sendMessage('init', {'ip':machine.ip});
    }

    function handleIncomingMessage(message, user) {
        let m = JSON.parse(message);
        switch (m.type) {
            case 'chat': //{'type':'chat', 'user': user, 'data':{'text': message, 'ts': ms_timestamp}}
                if(m.user === username) { writeMessage(m.data.text, false, m.data.ts); }
                else { writeMessage(m.data.text, user, m.data.ts); }
                break;
            case 'init': //{'type':'init', 'user': user, 'data':{'ip': ip_address}}
                //TODO: handle init messages from other users with possible username changes or new ip address values for the same username
                connectToUser(m.user, m.data.ip, confPort);
                restRequest('PUT', {'index':'chat_users', [m.user]: m.ip}, doNothing);
                break;
            case 'sync':
                //TODO: handle chat history syncing or syncing of other users IPs and data
                console.log(user + message)
                break;
            default:
                console.log('received unhandleable message:' + message);
        }
    }

    function sendMessage(type, data) {
        function sendAll(message) {
            Object.keys(team).forEach(function(user) {
                team[user].send(JSON.stringify(message));
            });
        }
        let message = {'type':type, 'user': username};
        switch (type) {
            case 'chat':
            case 'init':
                message.data = data;
                sendAll(message);
                break;
            case 'sync':
                //TODO: figure out how we want to handle chat history and syncing, especially as chat threads get very long
                break;
            default:
                throw new Error('need to specify a message type');
        }
    }

    let chatWindow = $('#mymsg');
    chatWindow.keyup(function(e){
        if(e.keyCode === 13 && chatWindow.val()) {
            let message = {'text': chatWindow.val(), 'ts': Date.now()};
            sendMessage('chat', message);
            chatWindow.val('');
        }
    });

    function writeMessage(m, user, ts) {
        let line = $("#chat-line").clone();
        let now = new Date(ts);
        if(user) {
            line.prop('class','incoming');
            line.find('#chat-user').text(user + ':').html();
        } else {
            line.prop('class','outgoing');
        }
        line.find('#chat-line-text').text(m).html();
        line.find('#timestamp').html(now.toLocaleString());
        line.show();
        let isScrolled = scrolled();
        $('#chatter').append(line);
        if(!isScrolled){scrollBottom();}
        if($('#chat-body').is(":hidden")){$('#chat-header-text').html('*unread messages*')}
    }

    function scrolled(){
        let c = $('#chatter');
        return c.prop('scrollHeight') - c.prop('clientHeight') >= c.prop('scrollTop') + 50
    }

    function scrollBottom(){
        let c = $('#chatter');
        c.prop('scrollTop', c.prop('scrollHeight') - c.prop('clientHeight'));
    }

    function toggleChat(){
        let wasHidden = $('#chat-body').is(":hidden");
        $('#chat-body').slideToggle();
        $('#chat-footer').slideToggle();
        if(wasHidden) {
            $('#chat-header-text').html('Conversations');
            $('#chat-header').css('background-color', 'var(--navbar-color)');
            $('#chat-header-button').prop('src', '/gui/img/min.png');
        }
        else {
            $('#chat-header').css('background-color', 'black');
            $('#chat-header-button').prop('src', '/gui/img/plus2.png');
        }
    }
</script>
